/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package average.multithread

import mu.KotlinLogging
import java.io.File
import java.io.FileInputStream
import java.util.Collections
import java.util.concurrent.Executors
import java.lang.Integer.parseInt
import java.util.stream.Collectors


class Monitor {
    private val log = KotlinLogging.logger { }

    companion object {
        private val lock: MutableSet<Int> = Collections.synchronizedSet(mutableSetOf())
    }

    fun runWithLock(f: () -> Unit) {
        log.info { "Try to get lock" }
        while (true) {
            if (lock.add(1)) {
                log.info { "Obtain Lock" }
                try {
                    f()
                } catch (t: Throwable) {
                    log.error { "Error during execution with lock" }
                } finally {
                    log.info { "Releasing lock" }
                    lock.clear()
                    break
                }
            }
        }
    }
}

class Evaluator {
    var average: Double = 0.0

    @Synchronized
    fun set(set: List<Int>) {
        if (set.isEmpty()) return
        average += set.average()
    }
}


fun main(args: Array<String>) {
    val log = KotlinLogging.logger { }
    val startTime = System.currentTimeMillis()
    val file = File("/home/killboard/Desktop/average-multithread/app/src/main/kotlin/average/multithread/input.csv")
    val stream = FileInputStream(file)

    val executor = Executors.newFixedThreadPool(20)
    val m = Monitor()
    val evaluator = Evaluator()

    var counter = 0
    val chunk = 9 * 100

    do {
        val buffer = stream.readNBytes(chunk)
        executor.submit {
            val intArray = String(buffer).split("\n").stream()
                .filter { it != "" }
                .map { parseInt(it) }
                .collect(Collectors.toList())

            log.info { "Reading chunk ${counter++}" }
            evaluator.set(intArray)
        }
    } while (buffer.isNotEmpty())

    executor.shutdown()
    while (!executor.isTerminated) {
    }
    val endTime = System.currentTimeMillis()
    val duration = (endTime - startTime);
    log.info { "Finished with time of ${duration}ms" }
    log.info { "Average: ${String.format("%.2f", evaluator.average)}" }
}
